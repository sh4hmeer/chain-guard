import axios from 'axios';
import { CVEData, Vulnerability, Application } from '../types';

const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

// Mock data for demo purposes
export const mockVulnerabilities: Vulnerability[] = [
  {
    id: 'vuln-1',
    cveId: 'CVE-2024-1234',
    description: 'Critical authentication bypass vulnerability in Slack Desktop application allowing unauthorized access to workspace data.',
    severity: 'CRITICAL',
    cvssScore: 9.8,
    affectedApps: [],
    publishedDate: '2024-10-01T10:00:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-1234']
  },
  {
    id: 'vuln-2',
    cveId: 'CVE-2024-5678',
    description: 'Remote code execution vulnerability in Zoom Client versions prior to 5.16.0.',
    severity: 'HIGH',
    cvssScore: 8.1,
    affectedApps: [],
    publishedDate: '2024-09-28T14:30:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-5678']
  },
  {
    id: 'vuln-3',
    cveId: 'CVE-2024-9012',
    description: 'Cross-site scripting (XSS) vulnerability in GitHub Enterprise Server.',
    severity: 'MEDIUM',
    cvssScore: 6.1,
    affectedApps: [],
    publishedDate: '2024-09-25T09:15:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-9012']
  },
  {
    id: 'vuln-4',
    cveId: 'CVE-2024-3456',
    description: 'Information disclosure vulnerability in Google Workspace admin console.',
    severity: 'LOW',
    cvssScore: 3.7,
    affectedApps: [],
    publishedDate: '2024-09-20T11:45:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-3456']
  }
];

export const mockApplications: Application[] = [
  {
    id: 'app-1',
    name: 'Slack',
    vendor: 'Slack Technologies',
    version: '4.35.0',
    category: 'Communication',
    addedDate: new Date().toISOString()
  },
  {
    id: 'app-2',
    name: 'Zoom',
    vendor: 'Zoom Video Communications',
    version: '5.15.5',
    category: 'Video Conferencing',
    addedDate: new Date().toISOString()
  },
  {
    id: 'app-3',
    name: 'GitHub',
    vendor: 'GitHub',
    version: 'Enterprise Server 3.10',
    category: 'Development',
    addedDate: new Date().toISOString()
  },
  {
    id: 'app-4',
    name: 'Google Workspace',
    vendor: 'Google',
    category: 'Productivity',
    addedDate: new Date().toISOString()
  }
];

/**
 * Fetch CVEs from NVD API
 * Note: NVD API has rate limits (5 requests per 30 seconds without API key)
 */
export const fetchCVEsFromNVD = async (
  keyword?: string,
  resultsPerPage: number = 10
): Promise<CVEData[]> => {
  try {
    const params: Record<string, string | number> = {
      resultsPerPage,
    };

    if (keyword) {
      params.keywordSearch = keyword;
    }

    const response = await axios.get(NVD_API_BASE, { params });
    return response.data.vulnerabilities.map((v: { cve: CVEData }) => v.cve);
  } catch (error) {
    console.error('Error fetching CVEs from NVD:', error);
    throw error;
  }
};

/**
 * Match vulnerabilities with tracked applications
 */
export const matchVulnerabilitiesToApps = (
  vulnerabilities: Vulnerability[],
  applications: Application[]
): Vulnerability[] => {
  return vulnerabilities.map(vuln => {
    const affectedApps = applications
      .filter(app => {
        // Simple string matching - in production, this would be more sophisticated
        const vulnText = `${vuln.description} ${vuln.cveId}`.toLowerCase();
        const appName = app.name.toLowerCase();
        const vendorName = app.vendor.toLowerCase();
        
        return vulnText.includes(appName) || vulnText.includes(vendorName);
      })
      .map(app => app.id);

    return {
      ...vuln,
      affectedApps
    };
  });
};

/**
 * Get mock data for demo
 */
export const getMockData = (applications: Application[]) => {
  const appVulns = matchVulnerabilitiesToApps(mockVulnerabilities, applications.length > 0 ? applications : mockApplications);
  
  return {
    applications: applications.length > 0 ? applications : mockApplications,
    vulnerabilities: appVulns
  };
};

/**
 * Fetch live vulnerabilities from NVD for user's application
 */
export const fetchLiveVulnerabilities = async (applications: Application[]): Promise<Vulnerability[]> => {
  if (applications.length === 0) {
    return [];
  }

  const allVulnerabilities: Vulnerability[] = [];
  const seenCveIds = new Set<string>();

  try {
    // Search for vulnerabilities for each application
    for (const app of applications) {
      // Search by application name
      const nameResults = await fetchCVEsFromNVD(app.name, 20);
      
      // Also search by vendor if available
      const vendorResults = app.vendor 
        ? await fetchCVEsFromNVD(app.vendor, 20)
        : [];

      // Combine and deduplicate results
      const combinedResults = [...nameResults, ...vendorResults];
      
      for (const cve of combinedResults) {
        const cveId = cve.id;
        if (!seenCveIds.has(cveId)) {
          seenCveIds.add(cveId);
          const vulnerability = convertCVEtoVulnerability(cve);
          // Only link to THIS specific application
          vulnerability.affectedApps = [app.id];
          allVulnerabilities.push(vulnerability);
        } else {
          // If we've seen this CVE before, add this app to the affected apps list
          const existingVuln = allVulnerabilities.find(v => v.id === cveId);
          if (existingVuln && !existingVuln.affectedApps.includes(app.id)) {
            existingVuln.affectedApps.push(app.id);
          }
        }
      }

      // Add delay between requests to respect rate limiting (5 requests per 30 seconds)
      await new Promise(resolve => setTimeout(resolve, 6000));
    }

    return allVulnerabilities;
  } catch (error) {
    console.error('Error fetching live vulnerabilities:', error);
    throw error;
  }
};

/**
 * Get vulnerabilities with fallback to mock data
 */
export const getVulnerabilities = async (
  applications: Application[], 
  useLiveData: boolean = true
): Promise<Vulnerability[]> => {
  if (!useLiveData) {
    const mock = getMockData(applications);
    return mock.vulnerabilities;
  }

  try {
    const liveVulns = await fetchLiveVulnerabilities(applications);
    // If no live vulnerabilities found, fall back to mock data
    if (liveVulns.length === 0) {
      console.log('No live vulnerabilities found, using mock data');
      const mock = getMockData(applications);
      return mock.vulnerabilities;
    }
    return liveVulns;
  } catch (error) {
    console.error('Failed to fetch live data, falling back to mock:', error);
    const mock = getMockData(applications);
    return mock.vulnerabilities;
  }
};

/**
 * Convert CVE data from NVD to our Vulnerability format
 */
export const convertCVEtoVulnerability = (cve: CVEData): Vulnerability => {
  const description = cve.descriptions.find(d => d.lang === 'en')?.value || 'No description available';
  const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0;
  const severity = cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'LOW';

  return {
    id: cve.id,
    cveId: cve.id,
    description,
    severity: severity.toUpperCase() as 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
    cvssScore,
    affectedApps: [],
    publishedDate: cve.published,
    lastModifiedDate: cve.lastModified,
    references: cve.references?.map(r => r.url) || [],
    status: 'active'
  };
};
